(use-modules (srfi srfi-1))
(use-modules (ice-9 rw))

(define write-string write-string/partial)

(define compile
  (lambda (output p)
    (letrec ((compile-quote
	       (lambda (p)
		 (cond
		   ((pair? p) (write-string "yume.cons(" output)
			      (compile-quote (car p))
			      (write-string ", " output)
			      (compile-quote (cdr p))
			      (write-string ")" output))
		   ((eq? p '()) (write-string "yume._null_list") output)
		   ((symbol? p) (write-string "new yume._symbol(\"" output)
				(write-string (symbol->string p) output)
				(write-string "\")" output))
		   ((boolean? p) (write-string (if p
						 "yume._boolean._true"
						 "yume._boolean._false")))
		   ((number? p) (write-string "new yume._number(" output)
				(write p)
				(write-string ")" output))
		   ((char? p) (write-string "new yume._char(" output)
			      (char->integer p)
			      (write-string ")" output))
		   ((string? p) (write-string "new yume._string(\"" output)
				(write-string p output)
				(write-string "\")" output))
		   ((vector? p) (raise "TODO"))
		   (else (raise (list "internal-compile-error" "unknown quote data" p))))))

	     (tokens
	       `((yume:label
		   ,(lambda (p)
		      (compile (cadr p))))

		 (yume:quote
		   ,(lambda (p)
		      (lambda ()
			(compile-quote (cadr p)))))

		 (yume:cons
		   ,(lambda (p)
		      (let ((a (compile (cadr p)))
			    (d (compile (caddr p))))
			(lambda ()
			  (write-string "yume.cons(" output)
			  (a)
			  (write-string ", " output)
			  (d)
			  (write-char #\) output)))))

		 (yume:car
		   ,(lambda (p)
		      (let ((s (compile (cadr p))))
			(lambda ()
			  (write-string "yume.car(" output)
			  (s)
			  (write-char #\) output)))))

		 (yume:cdr
		   ,(lambda (p)
		      (let ((s (compile (cadr p))))
			(lambda ()
			  (write-string "yume.cdr(" output)
			  (s)
			  (write-char #\) output)))))

		 (yume:set-car!
		   ,(lambda (p)
		      (let ((variable (compile (cadr p)))
			    (value (compile (caddr p))))
			(lambda ()
			  (write-string "yume.set_car_bang(" output)
			  (variable)
			  (write-string ", " output)
			  (value)
			  (write-char #\) output)))))

		 (yume:set-cdr!
		   ,(lambda (p)
		      (let ((variable (compile (cadr p)))
			    (value (compile (caddr p))))
			(lambda ()
			  (write-string "yume.set_cdr_bang(" output)
			  (variable)
			  (write-string "\", " output)
			  (value)
			  (write-char #\) output)))))

		 (yume:if
		   ,(lambda (p)
		      (let ((test (compile (cadr p)))
			    (true (compile (caddr p)))
			    (false (compile (cadddr p))))
			(lambda ()
			  (write-string "(function () {" output)
			  (newline output)
			  (write-string "if (" output)
			  (test)
			  (write-string ") {" output)
			  (newline output)
			  (write-string "return " output)
			  (true)
			  (write-string ";" output)
			  (newline output)
			  (write-string "} else {" output)
			  (newline output)
			  (write-string "return " output)
			  (false)
			  (write-string ";" output)
			  (newline output)
			  (write-string "}})()" output)))))

		 (yume:global-add
		   ,(lambda (p)
		      (let ((value (compile (caddr p))))
			(lambda ()
			  (write-string "yume.global_add(\"" output)
			  (write-string (symbol->string (cadr p)) output)
			  (write-string "\", " output)
			  (value)
			  (write-string ")" output)))))

		 (yume:global-get
		   ,(lambda (p)
		      (lambda ()
			(write-string "yume.global_get(\"" output)
			(write-string (symbol->string (cadr p)))
			(write-string "\")" output))))

		 (yume:procedure-new
		   ,(lambda (p)
		      (let ((fun (compile (cadr p)))
			    (scope (compile (caddr p))))
			(lambda ()
			  (write-string "new yume._procedure(" output)
			  (fun)
			  (write-string ", " output)
			  (scope)
			  (write-string ", " output)
			  (write (cadddr p))
			  (write-string ", " output)
			  (if (car (cddddr p))
			    (write-string "true" output)
			    (write-string "false" output))
			  (write-string ")" output)))))

		 (yume:procedure-call
		   ,(lambda (p)
		      (let ((fun (compile (cadr p)))
			    (cps (compile (caddr p)))
			    (args (compile (cadddr p))))
			(lambda ()
			  (write-string "yume.procedure_call(" output)
			  (fun)
			  (write-string ", " output)
			  (cps)
			  (write-string ", " output)
			  (args)
			  (write-string ")" output)))))

		 (yume:lambda-cps
		   ,(lambda (p)
		      (let ((name (cadr p)) (fun (compile (cadddr p))))
			(write-string "var P_" output)
			(write-string name output)
			(write-string " = function (cps, scope) {" output)
			(newline output)
			(write-string "return " output)
			(fun)
			(write-char #\; output)
			(newline output)
			(write-string "};" output)
			(newline output)
			(lambda ()
			  (write-string "P_" output)
			  (write-string name output)))))

		 (yume:continue-new
		   ,(lambda (p)
		      (let ((fun (compile (cadr p)))
			    (cps (compile (caddr p)))
			    (scope (compile (cadddr p))))
			(lambda ()
			  (write-string "new yume._continue(" output)
			  (fun)
			  (write-string ", " output)
			  (cps)
			  (write-string ", " output)
			  (scope)
			  (write-string ")" output)))))

		 (yume:continue-call
		   ,(lambda (p)
		      (let ((cps (compile (cadr p)))
			    (result (compile (caddr p))))
			(lambda ()
			  (write-string "yume.continue_call(" output)
			  (cps)
			  (write-string ", " output)
			  (result)
			  (write-string ")" output)))))

		 (yume:lambda-continue
		   ,(lambda (p)
		      (let ((name (cadr p)) (fun (compile (cadddr p))))
			(write-string "var C_" output)
			(write-string name output)
			(write-string " = function (cps, scope, result) {" output)
			(newline output)
			(write-string "return " output)
			(fun)
			(write-char #\; output)
			(newline output)
			(write-string "};" output)
			(newline output)
			(lambda ()
			  (write-string "C_" output)
			  (write-string name output)))))))

	     (compile
	       (lambda (p)
		 (cond ((pair? p)
			(let ((token (assq (car p) tokens)))
			  (if token
			    ((cadr token) p)
			    (let ((fun (compile (car p)))
				  (params (reverse (fold
						     (lambda (p tail)
						       (cons
							 (compile p)
							 tail))
						     '()
						     (cdr p)))))
			      (lambda ()
				(fun)
				(write-char #\( output)
				(pair-fold
				  (lambda (param tail)
				    (or (eq? param params) (write-string ", " output))
				    ((car param)))
				  '()
				  params)
				(write-string ")" output))))))
		       (else
			 (lambda ()
			   (cond
			     ((symbol? p) (write-string (symbol->string p) output))
			     ((boolean? p) (write-string (if p
							   "yume._boolean._true"
							   "yume._boolean._false")))
			     ((number? p) (write-string "new yume._number(" output)
					  (write p)
					  (write-string ")" output))
			     ((char? p) (write-string "new yume._char(" output)
					(char->integer p)
					(write-string ")" output))
			     ((string? p) (write-string "new yume._string(\"" output)
					  (write-string p output)
					  (write-string "\")" output))
			     ((vector? p) (raise "TODO"))
			     (else (raise (list "internal-compile-error" "unknown data" p))))))))))

      (write-string "var " output)
      (if (pair? (cdr (command-line)))
	(write-string (cadr (command-line)) output)
	(write-string "unamed_module" output))
      (write-string " = function() {" output)
      (newline output)
      (let ((ret (compile p)))
	(write-string "return ")
	(ret)
	(write-string ";")
	(newline output)
	(write-string "};")
	(newline output)))))

